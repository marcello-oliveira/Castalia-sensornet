//
// Generated file, do not edit! Created by nedtool 4.6 from src/node/communication/mac/cc2420Mac/CC2420Packet.msg.
//

#ifndef _CC2420PACKET_M_H_
#define _CC2420PACKET_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include "MacPacket_m.h"
// }}

/**
 * Enum generated from <tt>src/node/communication/mac/cc2420Mac/CC2420Packet.msg:87</tt> by nedtool.
 * <pre>
 * enum CC2420Packet_type
 * {
 * 
 * }
 * </pre>
 */
enum CC2420Packet_type {
};

/**
 * Class generated from <tt>src/node/communication/mac/cc2420Mac/CC2420Packet.msg:90</tt> by nedtool.
 * <pre>
 * packet CC2420Ieee802154Packet extends MacPacket
 * {
 *     uint16_t fcf;
 *     uint8_t dsn;
 *     uint16_t fcs;
 *     bool metaWasAcked;
 * }
 * </pre>
 */
class CC2420Ieee802154Packet : public ::MacPacket
{
  protected:
    uint16_t fcf_var;
    uint8_t dsn_var;
    uint16_t fcs_var;
    bool metaWasAcked_var;

  private:
    void copy(const CC2420Ieee802154Packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CC2420Ieee802154Packet&);

  public:
    CC2420Ieee802154Packet(const char *name=NULL, int kind=0);
    CC2420Ieee802154Packet(const CC2420Ieee802154Packet& other);
    virtual ~CC2420Ieee802154Packet();
    CC2420Ieee802154Packet& operator=(const CC2420Ieee802154Packet& other);
    virtual CC2420Ieee802154Packet *dup() const {return new CC2420Ieee802154Packet(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint16_t getFcf() const;
    virtual void setFcf(uint16_t fcf);
    virtual uint8_t getDsn() const;
    virtual void setDsn(uint8_t dsn);
    virtual uint16_t getFcs() const;
    virtual void setFcs(uint16_t fcs);
    virtual bool getMetaWasAcked() const;
    virtual void setMetaWasAcked(bool metaWasAcked);
};

inline void doPacking(cCommBuffer *b, CC2420Ieee802154Packet& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CC2420Ieee802154Packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/node/communication/mac/cc2420Mac/CC2420Packet.msg:96</tt> by nedtool.
 * <pre>
 * packet CC2420Packet extends CC2420Ieee802154Packet
 * {
 *     uint16_t destpan;
 *     uint16_t dest;
 *     uint16_t src;
 *     uint8_t type;
 * }
 * </pre>
 */
class CC2420Packet : public ::CC2420Ieee802154Packet
{
  protected:
    uint16_t destpan_var;
    uint16_t dest_var;
    uint16_t src_var;
    uint8_t type_var;

  private:
    void copy(const CC2420Packet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CC2420Packet&);

  public:
    CC2420Packet(const char *name=NULL, int kind=0);
    CC2420Packet(const CC2420Packet& other);
    virtual ~CC2420Packet();
    CC2420Packet& operator=(const CC2420Packet& other);
    virtual CC2420Packet *dup() const {return new CC2420Packet(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual uint16_t getDestpan() const;
    virtual void setDestpan(uint16_t destpan);
    virtual uint16_t getDest() const;
    virtual void setDest(uint16_t dest);
    virtual uint16_t getSrc() const;
    virtual void setSrc(uint16_t src);
    virtual uint8_t getType() const;
    virtual void setType(uint8_t type);
};

inline void doPacking(cCommBuffer *b, CC2420Packet& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CC2420Packet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/node/communication/mac/cc2420Mac/CC2420Packet.msg:103</tt> by nedtool.
 * <pre>
 * packet CC2420AckPacket extends CC2420Ieee802154Packet
 * {
 * }
 * 
 * /////////////////// MESSAGES
 * 
 * //enum CC2420MacControlMessage_type{
 * //	EVENT = 1 ;
 * //	COMMAND = 2 ;
 * //}
 * 
 * //enum CC2420MacControlMessage_interface{
 * //	SEND = 1 ;
 * //}
 * 
 * //enum CC2420MacControlMessage_event{
 * //	EVT_SENDDONE = 1 ;
 * //}
 * 
 * //enum CC2420MacControlMessage_command{
 * //	CMD_SEND = 1 ;
 * //	CMD_RESEND = 2 ;
 * //	CMD_CANCEL = 3 ;
 * //}
 * 
 * //enum CC2420MacControlMessage_error{
 * //	SUCCESS = 1 ;
 * //	FAIL = 2 ;
 * //	EBUSY = 3 ;
 * //	ERETRY = 4 ;
 * //	ECANCEL = 5 ;
 * //	EOFF = 6 ;
 * //	ESIZE = 7 ;
 * //}
 * </pre>
 */
class CC2420AckPacket : public ::CC2420Ieee802154Packet
{
  protected:

  private:
    void copy(const CC2420AckPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CC2420AckPacket&);

  public:
    CC2420AckPacket(const char *name=NULL, int kind=0);
    CC2420AckPacket(const CC2420AckPacket& other);
    virtual ~CC2420AckPacket();
    CC2420AckPacket& operator=(const CC2420AckPacket& other);
    virtual CC2420AckPacket *dup() const {return new CC2420AckPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, CC2420AckPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CC2420AckPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>src/node/communication/mac/cc2420Mac/CC2420Packet.msg:138</tt> by nedtool.
 * <pre>
 * message CC2420MacControlMessage extends MacControlMessage
 * {
 *     int mcmType @enum(Notification_type);
 *     int mcmInterface @enum(Notification_interface);
 *     int mcmEvent @enum(Notification_event);
 *     int mcmCommand @enum(Notification_command);
 *     uint8_t error @enum(tos_err_types);
 *     bool useCca;
 *     bool metaWasAcked;
 *     uint16_t metaDest;
 * }
 * </pre>
 */
class CC2420MacControlMessage : public ::MacControlMessage
{
  protected:
    int mcmType_var;
    int mcmInterface_var;
    int mcmEvent_var;
    int mcmCommand_var;
    uint8_t error_var;
    bool useCca_var;
    bool metaWasAcked_var;
    uint16_t metaDest_var;

  private:
    void copy(const CC2420MacControlMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CC2420MacControlMessage&);

  public:
    CC2420MacControlMessage(const char *name=NULL, int kind=0);
    CC2420MacControlMessage(const CC2420MacControlMessage& other);
    virtual ~CC2420MacControlMessage();
    CC2420MacControlMessage& operator=(const CC2420MacControlMessage& other);
    virtual CC2420MacControlMessage *dup() const {return new CC2420MacControlMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getMcmType() const;
    virtual void setMcmType(int mcmType);
    virtual int getMcmInterface() const;
    virtual void setMcmInterface(int mcmInterface);
    virtual int getMcmEvent() const;
    virtual void setMcmEvent(int mcmEvent);
    virtual int getMcmCommand() const;
    virtual void setMcmCommand(int mcmCommand);
    virtual uint8_t getError() const;
    virtual void setError(uint8_t error);
    virtual bool getUseCca() const;
    virtual void setUseCca(bool useCca);
    virtual bool getMetaWasAcked() const;
    virtual void setMetaWasAcked(bool metaWasAcked);
    virtual uint16_t getMetaDest() const;
    virtual void setMetaDest(uint16_t metaDest);
};

inline void doPacking(cCommBuffer *b, CC2420MacControlMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CC2420MacControlMessage& obj) {obj.parsimUnpack(b);}


#endif // ifndef _CC2420PACKET_M_H_

